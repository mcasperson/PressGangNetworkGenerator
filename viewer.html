
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>PressGang Visualization</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script type="application/javascript" src="http://code.jquery.com/jquery-2.0.3.min.js"></script>
		<style>
			body {
				color: #cccccc;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #050505;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #0080ff;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>
		<script src="three.min.js"></script>
		<script src="Detector.js"></script>
		<script src="extradata.js"></script>
		
		<script type="x-shader/x-vertex" id="vertexshader">

			uniform float amplitude;
			attribute float size;
			attribute vec3 customColor;

			varying vec3 vColor;

			void main() {

				vColor = customColor;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>
		
		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform vec3 color;
			uniform sampler2D texture;

			varying vec3 vColor;

			void main() {

				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );

			}

		</script>

		<script>
			/*
			 * Generate the LAY file using:
			 * java -Xmx768M -cp CCVisu.jar ccvisu.CCVisu -i topics.rsf -outformat LAY -iter 100 -dim 3 > topics.lay
			 * Run this page locally using:
			 * chrome --allow-file-access-from-files
			 */


			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, scene, renderer;

			var mesh;
			
			var topics = [];
			
			$.ajax({
			  dataType: "text",
			  url: "topics.lay",
			  success: function(topicData) {
				var lines = topicData.split("\n");
				for (var lineIndex = 0, lineCount = lines.length; lineIndex < lineCount; ++lineIndex) {
					if (lines[lineIndex].lenth != 0 && lines[lineIndex].substr(0, 1) != "#") {
						var topicDetails = lines[lineIndex].split("\t");
						if (topicDetails.length == 8) {
							topics.push({x: Number(topicDetails[1]), y: Number(topicDetails[2]), z: Number(topicDetails[3]), size: Number(topicDetails[4])});
						}
					}
				}				
				
				init();
				animate();
			  }
			});
			
			function init() {

				container = document.getElementById( 'container' );

				//

				camera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 5, 10000 );
				camera.position.z = 6000;

				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x050505, 2000, 7500 );
				
				attributes = {
	
					size: {	type: 'f', value: [] },
					customColor: { type: 'c', value: [] }
	
				};
	
				uniforms = {
	
					amplitude: { type: "f", value: 1.0 },
					color:     { type: "c", value: new THREE.Color( 0xffffff ) },
					texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "particle.png" ) },
	
				};				
				
				var shaderMaterial = new THREE.ShaderMaterial( {

					uniforms: 		uniforms,
					attributes:     attributes,
					vertexShader:   document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
	
					blending: 		THREE.AdditiveBlending,
					depthTest: 		false,
					transparent:	true
	
				});

				// create the particle variables
				var particleCount = topics.length,
				    particles = new THREE.Geometry();
				    
				// now create the individual particles
				for(var p = 0; p < particleCount; p++) {

				  var pX = topics[p].x,
				      pY = topics[p].y,
				      pZ = topics[p].z,
				      particle = new THREE.Vector3(pX, pY, pZ);
				
				  // add it to the geometry
				  particles.vertices.push(particle);
				}
				
				// create the particle system
				particleSystem =
				  new THREE.ParticleSystem(
				    particles,
				    shaderMaterial);
				    
				particleSystem.sortParticles = true;
				
				var values_size = attributes.size.value;
				var values_color = attributes.customColor.value;
	
	
				for( var v = 0; v < particleCount; v++ ) {							
					values_size[ v ] = topics[v].size;
					values_color[ v ] = new THREE.Color();
					values_color[ v ].setHSV(Math.random() * 255, 200, 255);
				}
				
				// add it to the scene
				scene.add(particleSystem);

				//

				renderer = new THREE.WebGLRenderer( { antialias: false, clearColor: 0x333333, clearAlpha: 1, alpha: false } );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor( scene.fog.color, 1 );

				container.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
			}

			function render() {

				var time = Date.now() * 0.001;

				particleSystem.rotation.x = time * 0.25;
				particleSystem.rotation.y = time * 0.5;

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
